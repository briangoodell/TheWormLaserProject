<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Worm Lasers</title>
    <link rel="stylesheet" href="main_scroll.css">
  </head>
  <body>
    <!-- <div class="spacer"><h2>The Untitled Laser Project</h2></div> -->
    <div class="spacer spacer--top">
        <h2>The Untitled Laser Project</h2>

        <div class="spacer-arrow" aria-hidden="true"></div>
    </div>

    <section id="blendSection">
      <div id="stage">
        <canvas id="c"></canvas>
        <div class="scroll-hint" aria-hidden="true">
            <span class="chev"></span>
        </div>

        <div class="headline">
          <h1>Cooling Stage</h1>
          <p>From idea to application</p>
        </div>
      </div>
    </section>

    <div class="spacer"><h2>Why?</h2></div>

    <script>
      const SOURCES = [
        "cooling_stage_images/v1.jpg",
        "cooling_stage_images/v2.jpg",
        "cooling_stage_images/v3.jpg",
        "cooling_stage_images/v4.jpg",
        "cooling_stage_images/v5.jpg",
        "cooling_stage_images/v6.jpg",
      ];

      // Vertical crop anchor within the "cover" crop:
      // 0   = align to top (show top of the image)
      // 0.5 = centered
      // 1   = align to bottom (show bottom of the image)
      const Y_ANCHOR = 0.23;

      // Pause briefly on each image before blending (Apple-ish)
      const HOLD = 0.22; // 0..0.8

      const section = document.getElementById("blendSection");
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d", { alpha: false });

      const clamp01 = (v) => Math.max(0, Math.min(1, v));
      const smoothstep = (t) => t * t * (3 - 2 * t);

      section.style.height = `${Math.max(2, SOURCES.length) * 100}vh`;

      function loadImages(srcs) {
        return Promise.all(srcs.map(src => new Promise((res, rej) => {
          const img = new Image();
          img.decoding = "async";
          img.loading = "eager";
          img.onload = () => res(img);
          img.onerror = () => rej(new Error(`Failed to load: ${src}`));
          img.src = src;
        })));
      }

      function getCanvasCssSize() {
        const r = canvas.getBoundingClientRect();
        return { cw: r.width, ch: r.height };
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const { cw, ch } = getCanvasCssSize();
        canvas.width = Math.max(1, Math.round(cw * dpr));
        canvas.height = Math.max(1, Math.round(ch * dpr));
        // draw in CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function drawCover(img, alpha = 1, yAnchor = 1) {
        const { cw, ch } = getCanvasCssSize();
        const iw = img.naturalWidth || img.width;
        const ih = img.naturalHeight || img.height;

        const s = Math.max(cw / iw, ch / ih);
        const dw = iw * s;
        const dh = ih * s;

        // Center horizontally
        const dx = (cw - dw) / 2;

        // For vertical, anchor within the available crop so we don't reveal blank bars
        // If dh > ch, extraCrop = dh - ch. yAnchor=0 => dy=0 (top), 0.5 => center, 1 => bottom.
        let dy;
        if (dh > ch) {
          const extra = dh - ch;
          const a = Math.max(0, Math.min(1, yAnchor));
          dy = -extra * a;
        } else {
          // no vertical crop; just center
          dy = (ch - dh) / 2;
        }

        ctx.globalAlpha = alpha;
        ctx.drawImage(img, dx, dy, dw, dh);
      }

      function getProgress() {
        const rect = section.getBoundingClientRect();
        const vh = window.innerHeight;
        const total = rect.height - vh;
        const scrolledInto = -rect.top;
        return total > 0 ? clamp01(scrolledInto / total) : 0;
      }

      function makeBlender(images, hold = 0.2) {
        return function render() {
          const t = getProgress();
          const n = images.length;
          if (n === 0) return;

          const { cw, ch } = getCanvasCssSize();
          ctx.clearRect(0, 0, cw, ch);

          if (n === 1) {
            drawCover(images[0], 1, Y_ANCHOR);
            ctx.globalAlpha = 1;
            return;
          }

          const segs = n - 1;
          const s = t * segs;
          const i = Math.min(n - 2, Math.max(0, Math.floor(s)));
          let f = s - i;

          const h = Math.max(0, Math.min(0.8, hold));
          if (f < h) f = 0;
          else if (f > 1 - h) f = 1;
          else f = (f - h) / (1 - 2 * h);

          f = smoothstep(f);

          drawCover(images[i], 1, Y_ANCHOR);
          drawCover(images[i + 1], f, Y_ANCHOR);
          ctx.globalAlpha = 1;
        };
      }

      let render = () => {};
      let ticking = false;
      function onScroll() {
        if (!ticking) {
          ticking = true;
          requestAnimationFrame(() => { render(); ticking = false; });
        }
      }

      (async function init() {
        const imgs = await loadImages(SOURCES);
        resizeCanvas();
        render = makeBlender(imgs, HOLD);
        render();

        window.addEventListener("scroll", onScroll, { passive: true });
        window.addEventListener("resize", () => { resizeCanvas(); render(); });
      })().catch(err => console.error(err));
    </script>
  </body>
</html>
