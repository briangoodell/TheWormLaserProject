<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Worms & Lasers</title>
    <link rel="stylesheet" href="main_scroll.css?v=20251225">
    <link rel="icon" type="image/x-icon" href="cooling_stage_images/worm_cursor.png">
  </head>
  <body>
    <!-- <div class="spacer"><h2>The Untitled Laser Project</h2></div> -->
    <div class="spacer spacer--top">
        <h2>The Laser Project</h2>
        <!-- <p>Creating Fictive Thermosensory Environments via Laser Heating</p> -->
        <p class="explanatoryText">The simple premise of this project -- <strong>to use a laser to dictate the temperature an animal is experiencing</strong> -- belies the challenging implementation of such a task. <br /><br />
          
        To start, our laser can only add energy (C. elegans aren't 
        <a href="https://web.stanford.edu/~rpam/dropoff/Phys041N/lecture6-lasercooling.pdf" target="_blank" rel="noopener noreferrer">that small!</a>) 
        and clearly cannot produce temperatures below that of the ambient environment.
        Less obvious is that at any temperature, cooling rate is proportional to the temperature
        differential between the heated area and the environment. Thus, if we want to act on the 
        few-second scale of a worm sampling the environment by swinging its head (less than a fifth of a mm) we need to be operating enough above the ambient temperature to have rapid cooling. 
        <!-- So, our cooling system serves 2 complementary purposes.  -->
      </p>

        <div class="spacer-arrow" aria-hidden="true"></div>
    </div>

    <section id="blendSection">
      <div id="stage">
        <canvas id="c"></canvas>
        <div class="scroll-hint" aria-hidden="true">
            <span class="chev"></span>
        </div>

        <div class="headline" id="imageHeadline">
          <!-- <h1>The Cooling Stage</h1>
          <p>An important component of the system</p> -->
        </div>
      </div>
    </section>
    <section id="handoffSection">
      <div class="handoff-sticky">
        <div class="project">
          <div class="project-media">
            <!-- This is the FINAL resting spot -->
            <img
              id="handoffTarget"
              src="cooling_stage_images/v6-clear-worm.png"
              alt="Cooling stage"
            />
          </div>

          <div class="project-text">
            <h2>Cooling</h2>
            <!-- <p>The Cooling Stage component of the system serves 2 complementary purposes: </p> -->
            <p>Importantly, heating the worm enough above ambient isn't feasible, as worms are most comfortable around room temp, and have severe heat shock responses, so the cooling stage allows both: </p>
            <ul class="standout_reasons">
              <li>Expanded experimental range</li>
              <li>Increased temperature responsiveness</li>
            </ul> 
            <p>
              <!-- Having a platform from which to cool the slide enables this project's core idea: <b>modulating laser power to determine experienced temperature</b>. <br /><br /> -->
              <!-- The key is that any given amount of energy added by the laser has a steady state with ambient heat loss, and that balance will resolve faster if there's a larger difference between it and the ambient temperature. In other words: the laser easily heats, but even if you turn it completely off, the cooling rate is determined by the distance from ambient temperature. -->
               
              The system I created completely solves that temperature change asymmetry (heating rate is bounded by the maximum laser power, but even turning it completely off, cooling is capped by how cold the material around it is) and allows for negative (movement towards colder temperature) thermotaxis experiments. <br \><br \>
              With the latest version of our cooling system, it can cool down to ~12°C, but is operated at a steady 15°C. From there, if the laser heats to 22° and is then turned off, it only takes 4 seconds to cool to 19°. This is more that sufficient as C. elegans perform best in gradients of 0.5-1.5 C/cm and take a few seconds to move a millimeter. They are usually kept at 20°C, so this is perfect for naturalist experiments.

              <!-- an experimental range of 17-23°C means 4-12cm of space depending on the gradient used in the experiement.  -->
            </p>
          </div>
        </div>
      </div>
    </section>

    <div class="text_content">
      <p>
        <!-- In preliminary tests, we found that just using the laser was able to create precise, consistent temperature profiles, but required a minimum experimental temperature which was already uncomfortably high for a C. elegans. This also essentially precluded any negative thermotaxis (movement towards colder temperatures) experiments, as we would have to start out at temperatures which would likely induce heat shock.<br /><br /> -->

        
        <!-- Beyond that, in order to run any reasonable negative thermotaxis (movement towards colder temperatures) experiments, you need a temperature floor that's not just whatever the ambient temperature happens to be at that moment. <br /> -->
        <!-- Unfortunately, C. elegans exhibit more robust negative thermotaxis than positive thermotaxis. -->
        <!-- it's just a bonus that it also results in a consistent, reproducible baseline.<br /> -->
        
        <!-- So, it makes sense to attempt to decrease the ambient environment, but the design had some specific criteria to fulfill: -->
        Importantly, the design achieves this while fulfilling the many requirements imposed by our imagining and heating systems:
      </p>
      <ul class="standout_reasons">
        <li>Not interfering with the confocal imaging path (lasers & camera FOV)</li>
        <li>Not interfering with the near infra-red tracking path (LED and camera)</li>
        <li>Not interfering with any of the wavelengths used in those paths</li>
        <li>Not interfering with the NIR stimulation (heating) laser</li>
        <li>Not interfering with the worm's environment or movement</li>
        <li>Not interfering with the movement of the stage</li>
        <li>Physically fit on the microscope</li>
      </ul>
      <p>
        To achieve these, the system involves a reference thermistor, sitting out of the way of the worm, as well as a pump, which transports a specifically chosen heat transfer fluid across the cooling device. That device has been optimized to prioritize even cooling (i.e. that the inflow side and center are not significantly colder than the outflow and edges, as tends to happen). The coolant, motor, and device geometry have each gone through many iterations; even the materials of the slide have been optimized, using sapphire for its superior thermal conductivity over glass.
        <br /><br />
        This setup also fulfills two practical requirements from the experimental side:</p>
      <ul class="standout_reasons">    
        <li>Hold a consistent temperature</li>
        <li>Impose no or a mild thermal gradient</li>
      </ul> 

      <p>
        This last point is important, as the cooling setup creates it's own ambient temperature gradient which needs to be accounted for.
      </p>
      <div style="text-align: center">
        <img src="cooling_stage_images/gradient_model_cmap_rev.png" alt="A heatmap of the cooling system's gradient" style="filter: invert(100%); width: 50vw; margin-left: auto;
    margin-right: auto;">
        <p style="width: 50vw; font-size: smaller; margin: auto;">
          Sampling of the gradient on multiple days shows a remarkably consistent gradient. This simple linear model is accurate to ~0.1°C for the average sample.
          <br /><br /><br /><br />
        </p>
      </div>
      <p>
        However how have I gotten these measurements? How can we be sure we're actually capturing temperatures experienced on the scale of a mm-long nematode?
      </p>
        
        <!-- <p>
          Maybe ideas
          Then, talk about materials, HT, sapphire. Prob bring in gradient.
          Also touch: Design, water, therm in corner. Pump type. 
          Mention objective?
      </p> -->
    </div>
    <!-- <div class="spacer">
    </div> -->
  <div class="text_content">
  <h2>Be the Worm!</h2>
  <br />
  </div>
  <section class="laser-widget">
    <div class="laser-wrap">
      <div id="laserPad" class="laser-pad" aria-label="Laser input area">
        <div id="worm" class="worm" aria-hidden="true"></div>
        <div id="glow" class="laser-glow" aria-hidden="true"></div>
      </div>

      <div class="laser-side">
        <div class="laser-bar-shell" aria-label="Laser value bar">
          <div id="laserBar" class="laser-bar"></div>
        </div>

        <label class="laser-label">
          Expression (x, y in [0,1])
          <input id="expr" class="laser-input" value="(x + y) / 2" />
        </label>

        <div id="exprError" class="laser-error" aria-live="polite"></div>
      </div>
    </div>
  </section>

  <style>
    .laser-widget { width: 100%; display: flex; justify-content: center; }
    .laser-wrap {
      width: min(900px, 96vw);
      display: grid;
      grid-template-columns: 1fr 220px;
      gap: 16px;
      align-items: stretch;
      margin-bottom: 5vw;
    }

    .laser-pad{
      position: relative;
      /* aspect-ratio: 50 / 24; */
      width: 50vw;
      height: 24vw;
      border: 1px solid rgba(0,0,0,0.12);
      background: #1f1f1f;
      overflow: hidden;
      user-select: none;

      /* Hide the real cursor inside the pad */
      cursor: none;
      touch-action: none;
    }

    .laser-side{ display:flex; flex-direction: column; gap: 12px; }

    .laser-bar-shell{
      height: 100%;
      min-height: 220px;
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.03);
      overflow: hidden;
      position: relative;
      width: 1vw;
    }
    .laser-bar{
      position:absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 0%;
      background: rgba(137, 37, 37, 0.65);
      transition: height 40ms linear;
    }

    .laser-label{
      display:flex;
      flex-direction: column;
      gap: 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .laser-input{
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.14);
      background: white;
      width: 100%;
      box-sizing: border-box;
    }

    .laser-row{ display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .laser-error{
      min-height: 1.2em;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(180, 0, 0, 0.9);
    }

    /* --- “Grey worm cursor” --- */
    .worm{
      position: absolute;              /* <<< critical */
      left: 0;                         /* will be overridden by JS */
      top: 0;                          /* will be overridden by JS */
      width: 48px;
      height: 48px;
      transform: translate(-50%, -50%) rotate(180deg);  /* <<< critical */
      transform-origin: 50% 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 120ms ease;

      background: url("cooling_stage_images/worm_cursor.png") center/contain no-repeat;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.15));
    }
    .worm::before, .worm::after { content: none; }

    .laser-glow{
      position: absolute;
      left: 0;
      top: 0;
      width: 2vw;
      height: 2vw;
      transform: translate(-50%, -50%);
      pointer-events: none;
      opacity: 0;

      /* A soft grey “blob” */
      background: radial-gradient(circle,
        rgba(190, 28, 28, 1) 0%,
        rgba(132, 32, 32, 0.5) 35%,
        rgba(8, 2, 2, 0) 70%
      );
      /* background: rgba(255, 35, 35, 0.753); */

      /* We’ll animate these from JS */
      /* filter: blur(10px); */
      transition: opacity 120ms ease;
      mix-blend-mode: multiply; /* optional; remove if you don't like the look */
    }




    @media (max-width: 720px) {
      .laser-wrap { grid-template-columns: 1fr; }
      .laser-bar-shell { height: 140px; min-height: 140px; }
    }
  </style>

  <script>
  (() => {
    const pad = document.getElementById("laserPad");
    const bar = document.getElementById("laserBar");
    const worm = document.getElementById("worm");
    const glow = document.getElementById("glow");
    const exprInput = document.getElementById("expr");
    const errEl = document.getElementById("exprError");

    const clamp01 = (t) => Math.max(0, Math.min(1, t));

    // --- Safe expression evaluator (no eval) ---
    // Supports:
    // numbers, x, y, pi, e
    // + - * / ^, parentheses
    // functions: sin cos tan asin acos atan sqrt abs floor ceil round min max clamp
    const FUNCS = {
      sin: Math.sin, cos: Math.cos, tan: Math.tan,
      asin: Math.asin, acos: Math.acos, atan: Math.atan,
      sqrt: Math.sqrt, abs: Math.abs,
      floor: Math.floor, ceil: Math.ceil, round: Math.round,
      min: Math.min, max: Math.max,
      clamp: (v, a, b) => Math.max(a, Math.min(b, v)),
    };

    function tokenize(s) {
      const tokens = [];
      let i = 0;

      const isSpace = (c) => /\s/.test(c);
      const isDigit = (c) => /[0-9]/.test(c);
      const isAlpha = (c) => /[A-Za-z_]/.test(c);

      while (i < s.length) {
        const c = s[i];
        if (isSpace(c)) { i++; continue; }

        // number
        if (isDigit(c) || (c === "." && isDigit(s[i+1]))) {
          let j = i + 1;
          while (j < s.length && /[0-9.]/.test(s[j])) j++;
          const num = Number(s.slice(i, j));
          if (!Number.isFinite(num)) throw new Error("Invalid number");
          tokens.push({ type: "num", value: num });
          i = j;
          continue;
        }

        // identifier (var or func)
        if (isAlpha(c)) {
          let j = i + 1;
          while (j < s.length && /[A-Za-z0-9_]/.test(s[j])) j++;
          const name = s.slice(i, j).toLowerCase();
          tokens.push({ type: "id", value: name });
          i = j;
          continue;
        }

        // operators / punctuation
        if ("+-*/^(),".includes(c)) {
          tokens.push({ type: "op", value: c });
          i++;
          continue;
        }

        throw new Error(`Unexpected character: "${c}"`);
      }
      return tokens;
    }

    // Shunting-yard to RPN, with support for functions + unary minus
    function toRPN(tokens) {
      const out = [];
      const stack = [];

      const prec = { "u-": 4, "^": 3, "*": 2, "/": 2, "+": 1, "-": 1 };
      const rightAssoc = { "^": true, "u-": true };

      // Track function argument counts
      const argCountStack = [];

      let prev = null;
      for (let k = 0; k < tokens.length; k++) {
        const t = tokens[k];

        if (t.type === "num") {
          out.push(t);
          prev = t;
          continue;
        }

        if (t.type === "id") {
          // If next token is "(" => function call
          const next = tokens[k + 1];
          if (next && next.type === "op" && next.value === "(") {
            stack.push({ type: "func", value: t.value });
            // We'll set arg count when we hit '('
          } else {
            out.push(t); // variable/constant
          }
          prev = t;
          continue;
        }

        if (t.type === "op") {
          if (t.value === "(") {
            stack.push(t);
            // if previous on stack is a func, start arg count
            const prevStack = stack[stack.length - 2];
            if (prevStack && prevStack.type === "func") argCountStack.push(0);
            prev = t;
            continue;
          }

          if (t.value === ")") {
            while (stack.length && stack[stack.length - 1].value !== "(") {
              out.push(stack.pop());
            }
            if (!stack.length) throw new Error("Mismatched parentheses");
            stack.pop(); // pop "("

            // If top is func, pop it too
            if (stack.length && stack[stack.length - 1].type === "func") {
              const fn = stack.pop();
              // Arg count: commas + 1 if there was an argument; 0 if empty ()
              let argc = argCountStack.pop() ?? 0;
              // Detect empty call: prev token was "("
              const empty = prev && prev.type === "op" && prev.value === "(";
              argc = empty ? 0 : (argc + 1);
              out.push({ type: "call", value: fn.value, argc });
            }

            prev = t;
            continue;
          }

          if (t.value === ",") {
            // function argument separator
            while (stack.length && stack[stack.length - 1].value !== "(") {
              out.push(stack.pop());
            }
            if (!stack.length) throw new Error("Misplaced comma");
            if (!argCountStack.length) throw new Error("Comma outside function call");
            argCountStack[argCountStack.length - 1] += 1;
            prev = t;
            continue;
          }

          // operator
          let op = t.value;
          // unary minus if at start or after operator or after "(" or ","
          if (op === "-" && (!prev || (prev.type === "op" && prev.value !== ")") || prev.type === "call")) {
            // Actually: treat as unary if previous token is null OR previous is an operator other than ')'
            // (The above line is conservative; if it misbehaves, we can simplify.)
            op = "u-";
          }

          const o1 = op;
          while (stack.length) {
            const top = stack[stack.length - 1];
            if (top.type !== "op") break;
            const o2 = top.value;
            if (o2 === "(") break;

            const p1 = prec[o1], p2 = prec[o2];
            if (p2 > p1 || (p2 === p1 && !rightAssoc[o1])) {
              out.push(stack.pop());
            } else break;
          }
          stack.push({ type: "op", value: o1 });
          prev = t;
          continue;
        }
      }

      while (stack.length) {
        const t = stack.pop();
        if (t.value === "(" || t.value === ")") throw new Error("Mismatched parentheses");
        out.push(t);
      }

      return out;
    }

    function evalRPN(rpn, vars) {
      const st = [];
      for (const t of rpn) {
        if (t.type === "num") st.push(t.value);
        else if (t.type === "id") {
          const name = t.value;
          if (name === "pi") st.push(Math.PI);
          else if (name === "e") st.push(Math.E);
          else if (name in vars) st.push(vars[name]);
          else throw new Error(`Unknown identifier: ${name}`);
        }
        else if (t.type === "op") {
          if (t.value === "u-") {
            if (st.length < 1) throw new Error("Bad unary minus");
            st.push(-st.pop());
            continue;
          }
          if (st.length < 2) throw new Error("Bad operator");
          const b = st.pop(), a = st.pop();
          switch (t.value) {
            case "+": st.push(a + b); break;
            case "-": st.push(a - b); break;
            case "*": st.push(a * b); break;
            case "/": st.push(a / b); break;
            case "^": st.push(Math.pow(a, b)); break;
            default: throw new Error(`Unknown operator: ${t.value}`);
          }
        }
        else if (t.type === "call") {
          const fn = FUNCS[t.value];
          if (!fn) throw new Error(`Unknown function: ${t.value}`);
          if (st.length < t.argc) throw new Error(`Not enough args for ${t.value}()`);
          const args = st.splice(st.length - t.argc, t.argc);
          const out = fn(...args);
          st.push(out);
        }
        else {
          throw new Error("Bad token");
        }
      }
      if (st.length !== 1) throw new Error("Expression did not resolve to a single value");
      return st[0];
    }

    let compiled = null;
    function compileExpression(s) {
      const tokens = tokenize(s);
      const rpn = toRPN(tokens);
      return (vars) => evalRPN(rpn, vars);
    }

    function setError(msg) {
      errEl.textContent = msg || "";
      exprInput.style.borderColor = msg ? "rgba(180,0,0,0.6)" : "rgba(0,0,0,0.14)";
    }

    // compile on input (debounced lightly)
    let compileTimer = null;
    function requestCompile() {
      clearTimeout(compileTimer);
      compileTimer = setTimeout(() => {
        try {
          compiled = compileExpression(exprInput.value);
          setError("");
        } catch (e) {
          compiled = null;
          setError(e.message || "Invalid expression");
        }
      }, 120);
    }
    exprInput.addEventListener("input", requestCompile);
    requestCompile();

    // --- Interaction / weathervane cursor ---
    let last = null;        // last pointer position in px
    let lastAngle = 0;      // for smoothing rotation
    let lastBar01 = 0;      // for smoothing bar
    let autoMin = Infinity, autoMax = -Infinity;

    function getNormXY(clientX, clientY) {
      const r = pad.getBoundingClientRect();
      const x = (clientX - r.left) / r.width;
      const y = (clientY - r.top) / r.height;
      return { x: clamp01(x), y: clamp01(y), rect: r, px: clientX - r.left, py: clientY - r.top };
    }

    function updateUI(eLike) {
      const { x, y, rect, px, py } = getNormXY(eLike.clientX, eLike.clientY);

      // Worm position
      worm.style.opacity = "1";
      worm.style.left = px + "px";
      worm.style.top  = py + "px";
      glow.style.opacity = "1";
      glow.style.left = px + "px";
      glow.style.top  = py + "px";


      // Compute motion vector for direction
      if (last) {
        const dx = px - last.px;
        const dy = py - last.py;
        const speed2 = dx*dx + dy*dy;

        if (speed2 > 0.5) {
          // weathervane behind motion
          const target = Math.atan2(dy, dx) + Math.PI;

          // wrap-aware angle smoothing:
          const s = 0.25; // smoothing factor
          const delta = Math.atan2(Math.sin(target - lastAngle), Math.cos(target - lastAngle));
          lastAngle = lastAngle + delta * s;
        }

      }
      last = { px, py };

      worm.style.transform = `translate(-50%, -50%) rotate(${(lastAngle * 180 / Math.PI).toFixed(1)}deg)`;

      // Evaluate expression to bar value
      let raw = 0;
      if (compiled) {
        try {
          raw = compiled({ x, y });
          if (!Number.isFinite(raw)) throw new Error("Expression returned non-finite number");
          setError("");
        } catch (err) {
          setError(err.message || "Error evaluating expression");
          raw = 0;
        }
      }

      let value01;
      value01 = clamp01(raw);


      // Smooth bar (lerp)
      const smooth = 0.2;
      lastBar01 = lastBar01 * smooth + value01 * (1 - smooth);

      // Drive glow from laser intensity (0..1)
      const intensity = clamp01(lastBar01);

      // Tune these to taste
      const minAlpha = 0.08;
      const maxAlpha = 1;

      const alpha  = minAlpha + (maxAlpha - minAlpha) * intensity;

      glow.style.opacity = alpha.toFixed(3);


      bar.style.height = (lastBar01 * 100).toFixed(1) + "%";
    }

    function onMove(e) { updateUI(e); }
    function onLeave() { worm.style.opacity = "0"; last = null; }
    function onTouch(e) { if (e.touches.length) updateUI(e.touches[0]); }

    pad.addEventListener("mousemove", onMove);
    pad.addEventListener("mouseleave", onLeave);
    pad.addEventListener("touchstart", onTouch, { passive: true });
    pad.addEventListener("touchmove", onTouch, { passive: true });
    pad.addEventListener("touchend", onLeave);

    // Reset auto-normalize range when changing mode or expression
    function resetAuto() { autoMin = Infinity; autoMax = -Infinity; }
    exprInput.addEventListener("input", resetAuto);
  })();
  </script>


    <div id="handoffOverlay" aria-hidden="true">
      <img id="handoffOverlayImg" src="cooling_stage_images/v6.jpg" alt="" />
    </div>

    <script>
      const SOURCES = [
        "cooling_stage_images/v1.jpg",
        "cooling_stage_images/v2.jpg",
        "cooling_stage_images/v3.jpg",
        "cooling_stage_images/v4.jpg",
        "cooling_stage_images/v5.jpg",
        "cooling_stage_images/v6.jpg",
      ];

      // Vertical crop anchor within the "cover" crop:
      // 0   = align to top (show top of the image)
      // 0.5 = centered
      // 1   = align to bottom (show bottom of the image)
      const Y_ANCHOR = 0.23;
      document.documentElement.style.setProperty("--ypos", `${Y_ANCHOR * 100}%`);

      // Pause briefly on each image before blending (Apple-ish)
      const HOLD = 0.22; // 0..0.8

      const section = document.getElementById("blendSection");
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d", { alpha: false });

      const clamp01 = (v) => Math.max(0, Math.min(1, v));
      const smoothstep = (t) => t * t * (3 - 2 * t);

      const handoffSection = document.getElementById("handoffSection");
      const handoffOverlay = document.getElementById("handoffOverlay");
      const handoffOverlayImg = document.getElementById("handoffOverlayImg");
      const handoffTarget = document.getElementById("handoffTarget");
      const imageHeadline = document.getElementById("imageHeadline");

      // how round the image gets when it lands
      const TARGET_RADIUS_PX = 22;

      // optional: keep full-screen briefly before it starts moving
      const HANDOFF_HOLD_START = 0.08;
      // optional: keep it landed briefly at the end
      const HANDOFF_HOLD_END = 0.06;

      const lerp = (a, b, t) => a + (b - a) * t;

      function sectionProgress(sec) {
        const rect = sec.getBoundingClientRect();
        const vh = window.innerHeight;
        const total = rect.height - vh;
        const scrolledInto = -rect.top;
        return total > 0 ? clamp01(scrolledInto / total) : 0;
      }

      function heldEase(t) {
        // Adds “holds” at ends: 0..holdStart stays 0, (1-holdEnd)..1 stays 1
        const hs = HANDOFF_HOLD_START;
        const he = HANDOFF_HOLD_END;
        if (t <= hs) return 0;
        if (t >= 1 - he) return 1;
        const u = (t - hs) / (1 - hs - he);
        return smoothstep(u);
      }


      section.style.height = `${Math.max(2, SOURCES.length) * 80}vh`;

      function loadImages(srcs) {
        return Promise.all(srcs.map(src => new Promise((res, rej) => {
          const img = new Image();
          img.decoding = "async";
          img.loading = "eager";
          img.onload = () => res(img);
          img.onerror = () => rej(new Error(`Failed to load: ${src}`));
          img.src = src;
        })));
      }

      function getCanvasCssSize() {
        const r = canvas.getBoundingClientRect();
        return { cw: r.width, ch: r.height };
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const { cw, ch } = getCanvasCssSize();
        canvas.width = Math.max(1, Math.round(cw * dpr));
        canvas.height = Math.max(1, Math.round(ch * dpr));
        // draw in CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function drawCover(img, alpha = 1, yAnchor = 1) {
        const { cw, ch } = getCanvasCssSize();
        const iw = img.naturalWidth || img.width;
        const ih = img.naturalHeight || img.height;

        const s = Math.max(cw / iw, ch / ih);
        const dw = iw * s;
        const dh = ih * s;

        // Center horizontally
        const dx = (cw - dw) / 2;

        // For vertical, anchor within the available crop so we don't reveal blank bars
        // If dh > ch, extraCrop = dh - ch. yAnchor=0 => dy=0 (top), 0.5 => center, 1 => bottom.
        let dy;
        if (dh > ch) {
          const extra = dh - ch;
          const a = Math.max(0, Math.min(1, yAnchor));
          dy = -extra * a;
        } else {
          // no vertical crop; just center
          dy = (ch - dh) / 2;
        }

        ctx.globalAlpha = alpha;
        ctx.drawImage(img, dx, dy, dw, dh);
      }

      function getProgress() {
        const rect = section.getBoundingClientRect();
        const vh = window.innerHeight;
        const total = rect.height - vh;
        const scrolledInto = -rect.top;
        return total > 0 ? clamp01(scrolledInto / total) : 0;
      }

      function makeBlender(images, hold = 0.2) {
        return function render() {
          const t = getProgress();
          const n = images.length;
          if (n === 0) return;

          const { cw, ch } = getCanvasCssSize();
          ctx.clearRect(0, 0, cw, ch);

          if (n === 1) {
            drawCover(images[0], 1, Y_ANCHOR);
            ctx.globalAlpha = 1;
            return;
          }

          const segs = n - 1;
          const s = t * segs;
          const i = Math.min(n - 2, Math.max(0, Math.floor(s)));
          let f = s - i;

          const h = Math.max(0, Math.min(0.8, hold));
          if (f < h) f = 0;
          else if (f > 1 - h) f = 1;
          else f = (f - h) / (1 - 2 * h);

          f = smoothstep(f);

          drawCover(images[i], 1, Y_ANCHOR);
          drawCover(images[i + 1], f, Y_ANCHOR);
          ctx.globalAlpha = 1;
        };
      }

      function updateHandoff() {
        const rect = handoffSection.getBoundingClientRect();
        const vh = window.innerHeight;

        const HANDOFF_DURATION_VH = 1.1; // try 0.9 (snappier) to 1.4 (slower)
        const p = clamp01((vh - rect.top) / (vh * HANDOFF_DURATION_VH));

        if (p <= 0) {
          canvas.style.opacity = "1";
          imageHeadline.style.opacity = "1";
          handoffOverlay.style.opacity = "0";
          handoffTarget.style.opacity = "0";
          return;
        }

        canvas.style.opacity = "0";
        imageHeadline.style.opacity = "0";
        handoffOverlay.style.opacity = "1";

        const e = heldEase(p);

        const start = { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };

        const endRect = handoffTarget.getBoundingClientRect();
        const end = { left: endRect.left, top: endRect.top, width: endRect.width, height: endRect.height };

        const L = lerp(start.left, end.left, e);
        const T = lerp(start.top, end.top, e);
        const W = lerp(start.width, end.width, e);
        const H = lerp(start.height, end.height, e);

        handoffOverlay.style.left = `${L}px`;
        handoffOverlay.style.top = `${T}px`;
        handoffOverlay.style.width = `${W}px`;
        handoffOverlay.style.height = `${H}px`;

        const r = lerp(0, TARGET_RADIUS_PX, e);
        handoffOverlayImg.style.borderRadius = `${r}px`;

        if (p >= 0.999) {
          handoffOverlay.style.opacity = "0";
          handoffTarget.style.opacity = "1";
          imageHeadline.style.opacity = "0";

        } else {
          handoffTarget.style.opacity = "0";
        }
      }


      let render = () => {};
      let ticking = false;
      function onScroll() {
        if (!ticking) {
          ticking = true;
          requestAnimationFrame(() => {
            render();
            updateHandoff();
            ticking = false;
          });
        }
      }


      (async function init() {
        const imgs = await loadImages(SOURCES);
        resizeCanvas();
        render = makeBlender(imgs, HOLD);
        render();
        updateHandoff();


        window.addEventListener("scroll", onScroll, { passive: true });
        // window.addEventListener("resize", () => { resizeCanvas(); render(); });
        window.addEventListener("resize", () => {
          resizeCanvas();
          render();
          updateHandoff();
        });

      })().catch(err => console.error(err));
    </script>
  </body>
</html>
